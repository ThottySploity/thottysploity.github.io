<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Terminal</title>
    <link>/</link>
    <description>Recent content on Terminal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 20 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>About</title>
      <link>/about/</link>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>Hello everyone,
I’m Thanatos, also known as Thottysploity. Currently, I’m pursuing a bachelor’s degree in Cyber Security. My insatiable curiosity for hacking has led me on a path of exploration and learning. I specialize in exploit development, post-exploitation techniques like lateral movement, active directory exploitation, and firmware exploitation.
As a security researcher, I’m devoted to helping the cyber community defend themselves against malicious hackers driven by financial gain or the desire to cause harm.</description>
      <content>&lt;p&gt;Hello everyone,&lt;/p&gt;
&lt;p&gt;I’m Thanatos, also known as Thottysploity. Currently, I’m pursuing a bachelor’s degree in Cyber Security. My insatiable curiosity for hacking has led me on a path of exploration and learning. I specialize in exploit development, post-exploitation techniques like lateral movement, active directory exploitation, and firmware exploitation.&lt;/p&gt;
&lt;p&gt;As a security researcher, I’m devoted to helping the cyber community defend themselves against malicious hackers driven by financial gain or the desire to cause harm. Notably, during my first year as a bachelor’s student, I achieved a significant milestone by creating a Proof-of-Concept for a Rust version of Mimikatz, now known as mimikatz-rs.&lt;/p&gt;
&lt;p&gt;What makes my journey even more remarkable is that I embarked on it at the age of 11, teaching myself everything I know about cybersecurity. From that young age, I’ve been driven by self-motivation and a thirst for knowledge.&lt;/p&gt;
&lt;p&gt;I firmly believe that a strong foundation of self-learning and personal growth is essential in the ever-evolving field of cybersecurity. While pursuing my bachelor’s degree, I continuously seek practical experiences and conduct independent research to stay up-to-date with the latest trends and emerging threats.&lt;/p&gt;
&lt;p&gt;In conclusion, my passion for cybersecurity, which started at a young age and has been entirely self-taught, has shaped me into a dedicated security researcher. I’m committed to expanding my knowledge, contributing to the community, and ensuring a safer digital world for all.&lt;/p&gt;
&lt;h1 id=&#34;certifications&#34;&gt;Certifications&lt;/h1&gt;
&lt;p&gt;Cisco Certified Network Associate&lt;/p&gt;
&lt;p&gt;Cisco Network Security Specialist (Certificate of Completion)&lt;/p&gt;
&lt;p&gt;Ndg-linux-essentials (Cisco)&lt;/p&gt;
&lt;p&gt;TryHackMe RedTeam Path (Certificate of Completion)&lt;/p&gt;
&lt;h1 id=&#34;some-certifications-i-still-wanna-get&#34;&gt;Some certifications I still wanna get&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.offsec.com/courses/pen-200/&#34;&gt;Offensive Security Certified Professional (OSCP)&lt;/a&gt;
&lt;a href=&#34;https://www.offsec.com/courses/exp-301/&#34;&gt;Offensive Security Exploit Developer (OSED/EXP-301)&lt;/a&gt;
&lt;a href=&#34;https://institute.sektor7.net/red-team-operator-malware-development-essentials&#34;&gt;Red team operator Malware development (Sektor7)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;languages-ranked-based-on-my-proficiency-from-highest-to-lowest-according-to-my-reading-and-writing-abilities&#34;&gt;Languages ranked based on my proficiency from highest to lowest, according to my reading and writing abilities.&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Rust (safe code and unsafe code (ex. windows API, NT calls or libc))&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;C#&lt;/li&gt;
&lt;li&gt;PHP&lt;/li&gt;
&lt;li&gt;Python&lt;/li&gt;
&lt;li&gt;SQL&lt;/li&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;formal-education&#34;&gt;Formal education&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Bachelors of Science in Cyber Security, Infrastructure and Management (2020-2024)&lt;/li&gt;
&lt;li&gt;System administration degree (2017-2020)&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Masquerading Process Environment Block (PEB) using Rust</title>
      <link>/posts/masqpeb/</link>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/masqpeb/</guid>
      <description>1 Why? In the realm of cybersecurity, adversaries often employ masquerading techniques to cloak their programs, making them appear genuine or harmless to both users and security tools. This deceptive strategy is purposefully employed to elude detection and evade defensive measures.
2 What is the Process Environment Block (PEB) The Process Environment Block (PEB) holds essential process information for the current running process. Comprising nineteen entries, it serves as a user-mode representation of the process, possessing the highest-level knowledge in kernel mode and the lowest-level understanding in user mode.</description>
      <content>&lt;h1 id=&#34;1-why&#34;&gt;&lt;code&gt;1&lt;/code&gt; Why?&lt;/h1&gt;
&lt;p&gt;In the realm of cybersecurity, adversaries often employ masquerading techniques to cloak their programs, making them appear genuine or harmless to both users and security tools. This deceptive strategy is purposefully employed to elude detection and evade defensive measures.&lt;/p&gt;
&lt;h1 id=&#34;2-what-is-the-process-environment-block-peb&#34;&gt;&lt;code&gt;2&lt;/code&gt; What is the Process Environment Block (PEB)&lt;/h1&gt;
&lt;p&gt;The Process Environment Block (PEB) holds essential process information for the current running process. Comprising nineteen entries, it serves as a user-mode representation of the process, possessing the highest-level knowledge in kernel mode and the lowest-level understanding in user mode. Within the PEB lies valuable data concerning the running process, such as whether it is being debugged, the loaded modules, and the command line used to initiate the process.&lt;/p&gt;

&lt;img src=&#34;/img/peb-structure.png&#34;  alt=&#34;PEB Structure&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;21-why-is-the-peb-structure-interesting&#34;&gt;&lt;code&gt;2.1&lt;/code&gt; Why is the PEB Structure interesting?&lt;/h1&gt;
&lt;p&gt;The PEB structure holds a significant allure for both malware developers and Red teamers. Its manipulability from userland allows us to obscure crucial information about our process, including the loaded modules, execution path, executable, command line arguments, and even whether our process is under debugging. This makes it a valuable resource for crafting stealthy and evasive techniques.&lt;/p&gt;
&lt;h1 id=&#34;3-what-makes-our-process-different-from-explorerexe&#34;&gt;&lt;code&gt;3&lt;/code&gt; What makes our process different from explorer.exe?&lt;/h1&gt;
&lt;p&gt;To find out what makes our process different to explorer.exe we will have to compare the two. There are four places across two different structures within the PEB that define what kind of process it is, namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PEB_LDR_DATA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;31-peb_ldr_data-and-rtl_user_process_parameters-of-explorerexe&#34;&gt;&lt;code&gt;3.1&lt;/code&gt; PEB_LDR_DATA and RTL_USER_PROCESS_PARAMETERS of explorer.exe&lt;/h1&gt;
&lt;p&gt;I will be using WinDbg (downloaded from the Windows Store) to inspect the PEB structure of the explorer.exe process.&lt;/p&gt;
&lt;p&gt;When loading explorer.exe into WinDbg, we can see the PEB structure using the following command: &lt;code&gt;dt _peb @$peb&lt;/code&gt;

&lt;img src=&#34;/img/peb-explorer.png&#34;  alt=&#34;PEB Structure&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;From the debugger we can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_PEB_LDR_DATA&lt;/code&gt; is located at: &lt;code&gt;0x00007ff94471c4c0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt; is located  at &lt;code&gt;0x00000000006627c0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is however just the start, when inspecting the &lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt; we can see the &lt;code&gt;ImagePathName&lt;/code&gt; and the &lt;code&gt;CommandLine&lt;/code&gt;:

&lt;img src=&#34;/img/rtl_user_parameters.png&#34;  alt=&#34;rtl_user_process_parameters&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;Now we need to loop through the modules that are held by &lt;code&gt;PEB_LDR_DATA&lt;/code&gt;. The reason for this will become clear in a minute. When doing &lt;code&gt;dt _PEB_LDR_DATA 0x00007ff94471c4c0&lt;/code&gt; we can see a table entry list, the one we&amp;rsquo;re after is called &lt;code&gt;InLoadOrderModuleList&lt;/code&gt;.

&lt;img src=&#34;/img/ldr_table.png&#34;  alt=&#34;ldr_table&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;We take the first entry of the ldr data table and check it&amp;rsquo;s &lt;code&gt;FullDllName&lt;/code&gt; and &lt;code&gt;BaseDllName&lt;/code&gt;, wow look it&amp;rsquo;s &lt;code&gt;explorer.exe&lt;/code&gt;

&lt;img src=&#34;/img/table_ldr_entry.png&#34;  alt=&#34;LDR_DATA&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;Now we know how the explorer.exe process is supposed to look, from a debugger angle. But the question remains, how does the PEB of an other process look? Let&amp;rsquo;s take &lt;code&gt;notepad.exe&lt;/code&gt; as an example.

&lt;img src=&#34;/img/notepad_rtl.png&#34;  alt=&#34;LDR_DATA&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


We can see the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ImagePathName&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommandLine&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FullDllName&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BaseDllName&lt;/code&gt; is notepad.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we want to successfully masquerade our PEB we will have to overwrite those four variables. But how does this Rust code look? well.. here is the code :P&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Masquerade Peb&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-rust&#34; &gt;&lt;code&gt;
use ntapi::ntldr::LDR_DATA_TABLE_ENTRY;
use ntapi::ntpebteb::PEB;
use ntapi::ntrtl::{RtlEnterCriticalSection, RtlInitUnicodeString, RtlLeaveCriticalSection};
use ntapi::winapi::shared::ntdef::UNICODE_STRING;

use std::arch::asm;
use std::env;

/// Gets a pointer to the Thread Environment Block (TEB)
#[cfg(target_arch = &amp;#34;x86&amp;#34;)]
pub unsafe fn get_teb() -&amp;gt; *mut ntapi::ntpebteb::TEB {
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!(&amp;#34;mov {teb}, fs:[0x18]&amp;#34;, teb = out(reg) teb);
    teb
}

/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_arch = &amp;#34;x86_64&amp;#34;)]
pub unsafe fn get_teb() -&amp;gt; *mut ntapi::ntpebteb::TEB {
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!(&amp;#34;mov {teb}, gs:[0x30]&amp;#34;, teb = out(reg) teb);
    teb
}

/// Get a pointer to the Process Environment Block (PEB)
pub unsafe fn get_peb() -&amp;gt; *mut PEB {
    let teb = get_teb();
    let peb = (*teb).ProcessEnvironmentBlock;
    peb
}

// Convert the PWCH to a String
unsafe fn convert_mut_u16_to_string(ptr: *mut u16) -&amp;gt; String {
    if ptr.is_null() {
        return &amp;#34;failed&amp;#34;.to_string();
    }

    let mut len = 0;
    while *ptr.offset(len) != 0 {
        len &amp;#43;= 1;
    }

    let slice = std::slice::from_raw_parts(ptr, len as usize);

    let utf8_bytes: Vec&amp;lt;u8&amp;gt; = slice
        .iter()
        .flat_map(|&amp;amp;c| std::char::from_u32(c as u32).map(|ch| ch.to_string().into_bytes()))
        .flatten()
        .collect();

    match String::from_utf8(utf8_bytes) {
        Ok(s) =&amp;gt; s.to_string(),
        Err(_) =&amp;gt; &amp;#34;failed&amp;#34;.to_string(),
    }
}

// Convert a String to a PWCH
unsafe fn convert_string_to_mut_u16(s: String) -&amp;gt; *mut u16 {
    let utf16_data: Vec&amp;lt;u16&amp;gt; = s.encode_utf16().collect();
    let len = utf16_data.len();
    let ptr =
        std::alloc::alloc(std::alloc::Layout::from_size_align(len * 2, 2).unwrap()) as *mut u16;

    std::ptr::copy_nonoverlapping(utf16_data.as_ptr(), ptr, len);

    *ptr.add(len) = 0;

    ptr
}

fn main() {
    unsafe {
        let peb = get_peb();

        let windows_explorer = convert_string_to_mut_u16(&amp;#34;C:\\Windows\\explorer.exe&amp;#34;.to_string());
        let explorer = convert_string_to_mut_u16(&amp;#34;explorer.exe&amp;#34;.to_string());

        println!(&amp;#34;Masquerading ImagePathName and CommandLine&amp;#34;);

        RtlInitUnicodeString(&amp;amp;mut (*(*peb).ProcessParameters).ImagePathName as *mut UNICODE_STRING, windows_explorer);
        RtlInitUnicodeString(&amp;amp;mut (*(*peb).ProcessParameters).CommandLine as *mut UNICODE_STRING, windows_explorer);

        println!(&amp;#34;Preparing to masquerade FullDllName and BaseDllName&amp;#34;);

        RtlEnterCriticalSection((*peb).FastPebLock);

        let mut module_list = (*(*peb).Ldr).InLoadOrderModuleList.Flink as *mut LDR_DATA_TABLE_ENTRY;
        println!(&amp;#34;Traversing all modules&amp;#34;);
        while !(*module_list).DllBase.is_null() {
            let current_exe_path = get_current_exe();
            let utf8_name = convert_mut_u16_to_string((*module_list).FullDllName.Buffer);

            if utf8_name == current_exe_path {
                println!(&amp;#34;Masquerading FullDllName and BaseDllName&amp;#34;);
                RtlInitUnicodeString(&amp;amp;mut (*module_list).FullDllName as *mut UNICODE_STRING, windows_explorer);
                RtlInitUnicodeString(&amp;amp;mut (*module_list).BaseDllName as *mut UNICODE_STRING, explorer);
            }

            module_list = (*module_list).InLoadOrderLinks.Flink as *mut LDR_DATA_TABLE_ENTRY;
        }

        println!(&amp;#34;Masqueraded PEB&amp;#34;);
        RtlLeaveCriticalSection((*peb).FastPebLock);
    }
}

fn get_current_exe() -&amp;gt; String {
    match env::current_exe() {
        Ok(exe_path) =&amp;gt; exe_path.display().to_string(),
        Err(_) =&amp;gt; return &amp;#34;failed&amp;#34;.to_string(),
    }
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;When we run this code within our debugger and look at the PEB when it&amp;rsquo;s ran it&amp;rsquo;s course we get the following output:

&lt;img src=&#34;/img/masqueraded.png&#34;  alt=&#34;ldr_table&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


And thus have successfully masqueraded our process&#39; PEB to look exactly like explorer.exe&lt;/p&gt;
&lt;p&gt;The full code is also available here: &lt;a href=&#34;https://github.com/ThottySploity/masqueradepeb-rs&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Masquerading PEB is essential for staying stealthy and evading defenses. As demonstrated, it is not hard to implement and it also was kinda fun to do :)&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://attack.mitre.org/techniques/T1036/&#34;&gt;https://attack.mitre.org/techniques/T1036/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&#34;&gt;https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm&#34;&gt;https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://malwareandstuff.com/peb-where-magic-is-stored/&#34;&gt;https://malwareandstuff.com/peb-where-magic-is-stored/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Obtaining the latest decrypted firmware version for DIR-842</title>
      <link>/posts/dir-842/</link>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/dir-842/</guid>
      <description>1 Why DIR-842 and why D-LINK I hold no specific animosity towards, nor particular fascination with, D-LINK products. However, I’ve chosen to explore the firmware of D-LINK as a form of amusement. IoT devices, in general, are often known for their vulnerabilities. My intention is to potentially discover intriguing findings that can expand my knowledge while providing an enjoyable pastime during my free hours.
2 Three common firmware release scenarios There are three common scenarios associated with firmware releases, particularly in the case of routers.</description>
      <content>&lt;h1 id=&#34;1-why-dir-842-and-why-d-link&#34;&gt;&lt;code&gt;1&lt;/code&gt; Why DIR-842 and why D-LINK&lt;/h1&gt;
&lt;p&gt;I hold no specific animosity towards, nor particular fascination with, D-LINK products. However, I’ve chosen to explore the firmware of D-LINK as a form of amusement. IoT devices, in general, are often known for their vulnerabilities. My intention is to potentially discover intriguing findings that can expand my knowledge while providing an enjoyable pastime during my free hours.&lt;/p&gt;
&lt;h1 id=&#34;2-three-common-firmware-release-scenarios&#34;&gt;&lt;code&gt;2&lt;/code&gt; Three common firmware release scenarios&lt;/h1&gt;
&lt;p&gt;There are three common scenarios associated with firmware releases, particularly in the case of routers. When encountering an encrypted firmware, it is highly likely that the firmware’s release cycle falls into one of the following three scenarios.&lt;/p&gt;
&lt;p&gt;Now, let’s discuss the process of decrypting a firmware release. The procedure is straightforward: we revert to a previous firmware release. Essentially, a device needs to flash a valid firmware version in order to operate properly. An encrypted firmware version is considered invalid and would render the device dysfunctional. Therefore, the firmware must be decrypted before it can be flashed onto the device.&lt;/p&gt;
&lt;p&gt;One way to accomplish this is by acquiring the product in question, connecting to its console, and exploring for a firmware decryption program. However, since I am broke, I will be downloading the firmware directly from the vendor.&lt;/p&gt;
&lt;h1 id=&#34;21-scenario-1&#34;&gt;&lt;code&gt;2.1&lt;/code&gt; Scenario 1&lt;/h1&gt;
&lt;p&gt;Initially, when the firmware was initially shipped, it was completely unencrypted. However, as the updates were introduced, a decryption routine was implemented to facilitate future firmware updates. Therefore, all subsequent firmware releases are encrypted.&lt;/p&gt;

&lt;img src=&#34;/img/scenario1.png&#34;  alt=&#34;Scenario 1&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;22-scenario-2&#34;&gt;&lt;code&gt;2.2&lt;/code&gt; Scenario 2&lt;/h1&gt;
&lt;p&gt;The device firmware is encrypted in the original release. The vendor however changed the encryption scheme and released an unencrypted transition version.&lt;/p&gt;

&lt;img src=&#34;/img/scenario2.png&#34;  alt=&#34;Scenario 2&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Similar to scenario 1, we obtain the decryption routine from v1.2 and apply this to v1.3. The release notes usually contain helpful information regarding the version the user has to upgrade to before upgrading to the new firmware.&lt;/p&gt;
&lt;h1 id=&#34;23-scenario-3&#34;&gt;&lt;code&gt;2.3&lt;/code&gt; Scenario 3&lt;/h1&gt;
&lt;p&gt;The device firmware is encrypted in the original release. However the vendor decided to change the encryption scheme in newer firmware versions.&lt;/p&gt;

&lt;img src=&#34;/img/scenario3.png&#34;  alt=&#34;Scenario 3&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;In this scenario, acquiring the decryption routine poses a challenge without a straightforward solution. You have two options available: 1) acquire the device from the vendor and directly extract the unencrypted firmware from the hardware, or 2) engage in further analysis of the firmware, aiming to overcome the encryption and gain access.&lt;/p&gt;
&lt;h1 id=&#34;3-firmware-from-vendor&#34;&gt;&lt;code&gt;3&lt;/code&gt; Firmware from vendor&lt;/h1&gt;
&lt;p&gt;You can find a lot of firmwares just by googling, name of product + firmware. Through this method I found the firmware page for the AC12000 Wireless router. The site offers six different firmware versions and we start at the lowest possible version. We could’ve started at the highest possible version and worked our way down the version ladder, trying to extract everything and stopping at the one which actually extracts. But as highlighted in the previous three possible scenario’s I just start at the bottom and work my way up so I do not miss any important detail.&lt;/p&gt;
&lt;h1 id=&#34;31-reversing-the-vendor-gotten-firmware&#34;&gt;&lt;code&gt;3.1&lt;/code&gt; Reversing the vendor gotten firmware&lt;/h1&gt;
&lt;p&gt;Highlighted in red is the lowest possible firmware that D-LINK has available for DIR-842. We download this and get to reversing.&lt;/p&gt;

&lt;img src=&#34;/img/firmware1.png&#34;  alt=&#34;firmware from vendor&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;311-firmware-v10-300b18&#34;&gt;&lt;code&gt;3.1.1&lt;/code&gt; Firmware v1.0 (3.00B18)&lt;/h1&gt;
&lt;p&gt;I have a VM with binwalk and Ghidra installed. Ghidra is a free and open source reverse engineering tool developed by the NSA, while binwalk is a useful utility for extracting embedded files and executable code from a specified binary image.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v1.0&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.00B18$ ls
firmware.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.00B18$ binwalk -eM firmware.bin 

Scan Time:     2023-06-24 07:39:49
Target File:   /home/user/Desktop/DIR-842/firmware_3.00B18/firmware.bin
MD5 Checksum:  815ab88500a14ea7871356a490b80ca3
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0x6A7785EB, created: 2017-05-19 16:57:27, image size: 1226247 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xCD5C9222, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3616252 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 15765760 bytes; big endian size: 9564160 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The output of binwalk tells us that the firmware was not encrypted, otherwise it would have outputted nothing or something along the lines of “Encrypted”. The entropy of a file also gives a pointer to if the file has been encrypted or not. I encourage you to google how file entropy works :) Nothing notable has come up from reversing this firmware version and thus I decided to move onto the next firmware version (3.01B05).&lt;/p&gt;
&lt;h1 id=&#34;312-firmware-v11-301b05&#34;&gt;&lt;code&gt;3.1.2&lt;/code&gt; Firmware v1.1 (3.01B05)&lt;/h1&gt;
&lt;p&gt;The way of reversing firmware 3.01B05 takes the same steps as 3.00B18, namely just downloading it from the vendor site and trying to extract it using binwalk -eM.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v1.1&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.01B05$ ls
DIR-842C1_FW301b05.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.01B05$ binwalk -eM DIR-842C1_FW301b05.bin 

Scan Time:     2023-06-24 07:55:46
Target File:   /home/user/Desktop/DIR-842/firmware_3.01B05/DIR-842C1_FW301b05.bin
MD5 Checksum:  cbe17b3fe6d3bdfe8123b215d7db39e5
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xFB966859, created: 2017-08-16 08:50:01, image size: 1225530 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xC35F7959, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3616196 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As we can see in the output of binwalk, this firmware is also not encrypted and we can extract it and walk through it. However since our goal is to get the most recent version we keep moving forward. No major findings concerning an encryption/decryption scheme have been found in this firmware.&lt;/p&gt;
&lt;h1 id=&#34;313-firmware-v20-310b05&#34;&gt;&lt;code&gt;3.1.3&lt;/code&gt; Firmware v2.0 (3.10B05)&lt;/h1&gt;
&lt;p&gt;One noticeable aspect (which I hope grabs your attention as well) is the version update. We transitioned from versions 3.00 and 3.01 to version 3.10, suggesting the likelihood of significant modifications in this release. Upon downloading this version, we obtain two files: &lt;code&gt;DIR842C1_FW310b05.bin&lt;/code&gt; and &lt;code&gt;DIR842C1_FW302b03_middle.bin&lt;/code&gt;.&lt;/p&gt;

&lt;img src=&#34;/img/firmware_version_change.png&#34;  alt=&#34;firmware version changes&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Now we see &lt;code&gt;DIR842C1_FW302b03_middle.bin&lt;/code&gt; we can assume that this is the unencrypted firmware version that holds the decryption scheme for all the future firmware versions. All that is left to do is extract the data from this firmware.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v2.0&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05$ binwalk -eM DIR842C1_FW302b03_middle.bin 

Scan Time:     2023-06-24 08:16:57
Target File:   /home/user/Desktop/DIR-842/firmware_3.10B05/DIR842C1_FW302b03_middle.bin
MD5 Checksum:  98868352a4913aee2d2da4acd8e1a04e
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA33A0532, created: 2018-07-02 07:26:57, image size: 1234680 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xE2D6A8D0, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 11572736 bytes; big endian size: 9875456 bytes
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;If only there was a way to check if this middle firmware is our holy grail… remember those release notes? well thank you D-LINK because they tell you exactly what you need to do. Here is the example of the latest firmware version &lt;code&gt;3.13B05&lt;/code&gt;.&lt;/p&gt;

&lt;img src=&#34;/img/release-notes.png&#34;  alt=&#34;firmware release notes&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;They quite literally tell you; the firmware v3.13 must be upgraded from the transitional version of firmware v3.02b03_middle. Now our job is, figuring out how this middle firmware can decrypt future firmware versions. Not too hard right?&lt;/p&gt;
&lt;p&gt;Firstly, mainly because I’m lazy, we find the difference between the middle firmware and the unencrypted firmware from v1.0. This way we can see what was added in this firmware image.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;finding the needle in the haystack&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05$ diff -qr _DIR842C1_FW302b03_middle.bin.extracted _DIR-842C1_FW301b05.bin.extracted | grep &amp;#34;Only in&amp;#34;
...
`Only in _DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin: encimg`
...

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The diff command returns a lot of entries, we only loop through the “Only In” so we only return the results which are in the middle firmware. When spitting through all the entries one catches my eye &lt;code&gt;encimg&lt;/code&gt; which stands for &lt;code&gt;encryptimage&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, what happends if we want to binwalk over an encrypted version of: 3.13B05? Lets try!&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalking over encrypted firmware&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ ls
DIR842C1_FW313WWb05.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ binwalk -eM DIR842C1_FW313WWb05.bin 

Scan Time:     2023-06-24 08:31:18
Target File:   /home/user/Desktop/DIR-842/firmware_3.13B05/DIR842C1_FW313WWb05.bin
MD5 Checksum:  ae141c12535cae08e49e4876410ebb9d
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ 

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As you can see, we get no output. We already expected this since this firmware is encrypted. So let’s decrypt it and extract it!&lt;/p&gt;
&lt;p&gt;We think that &lt;code&gt;_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin/encimg&lt;/code&gt; is the binary responsible for encrypting/decrypting the image, so let’s start here. When googling around a bit for encimg, openwrt (mentioned in references) explains: key/iv can be dumped by calling strings on the encimg binary found in the filesystem. Further aiding to the feeling that encimg is responsible for encryption and decryption. When executing a &lt;code&gt;file encimg&lt;/code&gt; we get the following output: &lt;code&gt;encimg: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped&lt;/code&gt; Since my system is not MIPS based, we can do a qemu trick (as referenced in zerodayinitiative source).&lt;/p&gt;
&lt;p&gt;First we copy the firmware we want to decrypt to the /usr/sbin folder where the encimg is also present, this makes decrypting so much easier:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;6&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;6&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Copying target firmware over&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ cp /home/user/Desktop/DIR-842/firmware_3.13B05/DIR842C1_FW313WWb05.bin /home/user/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin/firmware.bin

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;7&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;7&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;emulating MIPSEL&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ cp /usr/bin/qemu-mipsel-static ./usr/sbin/
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ sudo chroot . /bin/sh

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Once in the busybox shell, you might still need to move to the right folder (for this instance /usr/sbin) Once there we can execute the encimg file and see the following options:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;8&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;8&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;encimg&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

./encimg
no signature specified!
Usage: encimg {OPTIONS}
   -h                      : show this message.
   -v                      : Verbose mode.
   -i {input image file}   : input image file.
   -e                      : encode file.
   -d                      : decode file.
   -s                      : signature.

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The signature that this needs is found at: &lt;code&gt;/home/user/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/etc/config/fw_sign&lt;/code&gt; (firmware signature) which is: &lt;code&gt;wrgac65_dlink.2015_dir842&lt;/code&gt;&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;9&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;9&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;encimg decrypt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

./encimg -d -i DIR842C1_FW313WWb05.bin -s wrgac65_dlink.2015_dir842
The file length of DIR842C1_FW313WWb05.bin is 11280544

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The encimg does not print out if it was successful, it only does “the file length”. Once the encimg has ran it’s course, we can copy the now overwritten, but decrypted image back and binwalk it.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;10&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;10&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalking decrypted firmware image&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;


user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin$ cp DIR842C1_FW313WWb05.bin ~/Desktop/DIR-842/firmware_3.13B05/firmware_decrypted.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ ls
DIR842C1_FW313WWb05.bin  firmware_decrypted.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ binwalk -eM firmware_decrypted.bin 

Scan Time:     2023-06-24 08:52:19
Target File:   /home/user/Desktop/DIR-842/firmware_3.13B05/firmware_decrypted.bin
MD5 Checksum:  c40930278051bbf66f24a657676dd5b4
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA5A9FEC, created: 2019-09-10 02:41:50, image size: 1234827 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xAAFF08AD, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 2136320 bytes; big endian size: 10035200 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As we can now see, we can binwalk over the decrypted image of the newest DIR-842 firmware for the AC12000 Wireless Router.&lt;/p&gt;
&lt;h1 id=&#34;4-conclusion&#34;&gt;&lt;code&gt;4&lt;/code&gt; Conclusion&lt;/h1&gt;
&lt;p&gt;Reversing this firmware was a fun practice, when we look back at the whole firmware release cycle we can conclude the following: Version 3.00 and 3.01 were completely unencrypted and had no decryption scheme in it’s firmware. When coming towards firmware 3.10 we saw a big change. Firmware 3.10 was unencrypted but held the decryption scheme for all future firmwares.&lt;/p&gt;
&lt;h1 id=&#34;5-references&#34;&gt;&lt;code&gt;5&lt;/code&gt; References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware&#34;&gt;https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kali.org/tools/binwalk/&#34;&gt;https://www.kali.org/tools/binwalk/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openwrt.org/inbox/toh/d-link/dir-x1860_a1&#34;&gt;https://openwrt.org/inbox/toh/d-link/dir-x1860_a1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
